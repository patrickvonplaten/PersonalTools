#!/usr/bin/env python3
import sys
import numpy as np 
import subprocess
import matplotlib.pyplot as plt
import matplotlib
import ipdb
NUM_OF_DATAPOINTS = 125
LAYERS_TO_EXTRACT = ['CNNLayer1Filter50','CNNLayer2Filter50','CNNLayer1Filter200','CNNLayer2Filter200','CNNLayer1Filter400','CNNLayer2Filter400']

logFilePath = sys.argv[1]
plotPathToSave = sys.argv[2]

def getCurrentPath():
    process = subprocess.Popen('pwd'.split(), stdout=subprocess.PIPE)
    output, _ = process.communicate()
    return output[:-1].decode('utf-8')

def readInLogFileToDict(logFilePath, methodType, statType):
    dictToPlot = {}
    layerCounter = {}
    with open(logFilePath, 'r') as logFile:
        lines = logFile.readlines()
        numElements = sum(LAYERS_TO_EXTRACT[0] in line for line in lines)
        intervalLength = int(numElements/NUM_OF_DATAPOINTS)
        for line in lines:
            processLine(line, dictToPlot, layerCounter, methodType, statType, intervalLength)
    return dictToPlot, intervalLength

def processLine(line, dictToPlot, layerCounter, methodType, statType, intervalLength):
    for layerName in LAYERS_TO_EXTRACT:
        if(methodType in line and statType in line and layerName in line):
            value = extractValueFromLine(line, methodType, statType)
            layerCounter[layerName] = layerCounter.get(layerName, 0) + 1
            dictToPlot[layerName] = dictToPlot.get(layerName, [0])

            if(layerCounter[layerName] % intervalLength == 0):
                if(methodType in ['Mean', 'Var']):
                    dictToPlot[layerName][-1] = dictToPlot[layerName][-1]/float(intervalLength)
                dictToPlot[layerName].append(value)
            else:
                if(methodType in ['Mean', 'Var']):
                    dictToPlot[layerName][-1] += value
                elif(methodType == 'Max'):
                    dictToPlot[layerName][-1] = max(dictToPlot[layerName][-1], value)
                elif(methodType == 'Min'):
                    dictToPlot[layerName][-1] = min(dictToPlot[layerName][-1], value)
            
def extractValueFromLine(line, methodType, statType):
    value = float(extractFeature(line.strip(), statType))
    return value

def extractFeature(line, feature):
    return line.split(feature + ':')[-1].split(' ')[0]
    
def plotStatForAllLayers(dictToPlot, methodType, statType, ax, intervalLength):
    for layer in dictToPlot.keys():
        values = dictToPlot[layer]
        ax.plot(np.arange(len(values)), np.asarray(values), label=layer)
    ax.set_title(methodType + ' - ' + statType)
    ax.set_xlabel('Forward Pass Idx with one unit being {} Forward Passes'.format(intervalLength))
    if(statType in ['Mean','Var']):
        ax.set_ylabel('Average {}'.format(methodType))
    elif(statType in ['Max','Min']):
        ax.set_ylabel(methodType)
    ax.legend()

curPath = getCurrentPath()
statsToPlot = ['Mean','Var','Max']
methodsToPlot = ['Forward']
fig, axs = plt.subplots(len(statsToPlot), len(methodsToPlot), figsize=(20,30))
if(len(methodsToPlot) == 1):
    axs = [ [ax] for ax in axs ]
for i in range(len(statsToPlot)):
    for j in range(len(methodsToPlot)):
        dictToPlot, intervalLength = readInLogFileToDict(logFilePath, methodsToPlot[j], statsToPlot[i])
#        ipdb.set_trace()
        plotStatForAllLayers(dictToPlot, methodsToPlot[j], statsToPlot[i], axs[i][j], intervalLength)
plt.savefig(curPath + '/' + plotPathToSave)
